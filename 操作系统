
 https://www.jianshu.com/p/d254b138de03
 https://blog.csdn.net/godloveyuxu/article/details/80055879
 https://www.cnblogs.com/ze7777/p/7272827.html

 操作系统的特性？
   - 并发：同一段时间内多个程序执行(并行：同一时刻的多个事件)
   - 共享：系统中的资源可以被内存中多个并发执行的进线程共同使用
   - 虚拟：把一个物理实体虚拟化(虚拟内存)
   - 异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进
   
 操作系统的5大基本功能？
   - 进程管理：进程控制、进程调度、进程通信、进程同步
   - 内存管理：内存分配、内存保护、地址映射、内存扩充
   - 设备管理：分配I/O设备、完成I/O请求、提高I/O速度、提高设备利用率
   - 文件管理：目录管理、文件读写管理、文件共享和保护
   - 提供用户接口：命令接口(如API)、图形接口(如GUI)
 
 进程调度有哪些功能
   - 记录系统中所有进程的执行情况
   - 选择占有处理机的进程
   - 进行进程上下文切换
   
 用户态和核心态
   用户态： 执行用户自己的代码
   内核态： 执行的内核代码
   - 切换方式
      系统调用：主动，申请使用操作系统提供的服务程序完成工作，如printf库函数(方便编程)的实现最终还是调用了write这样的系统调用
      异常：被动，当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，
            也就转到了内核态，比如缺页异常
      外围设备的中断：被动，当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将
            要执行的指令转而去执行与中断信号对应的处理程序

 线程的实现方式?(也就是用户线程与内核线程的区别)
   - 用户级线程：线程管理的所有工作都由应用程序完成，内核意识不到线程的存在
   - 优点：线程切换不需要内核态特权
          可以为应用程序量身定做调度算法而不扰乱底层的操作系统调度程序
          可以在任何操作系统中运行，不需要对底层内核进行修改
   - 缺点：一个线程被阻塞，进程中的所有线程都会被阻塞
          不能利用多处理技术
   - 内核级线程： 有关线程管理的所有工作都是由内核完成的   
   - 优点：可以同时把同一个进程的多个线程调度到多个处理器中
          如果进程中的一个线程被阻塞，内核可以调度同一个进程中的另一个线程
   - 缺点：把控制从一个线程传送到进程中的另一个线程时，需要到内核的状态切换。

 程序、进程的区别
   - 程序是存储在计算机上的代码，静态的，进程是程序在数据集上的一次运行过程，动态的，包括程序段，数据段，进程控制块
   
 进程、线程的区别
   - 进程是资源分配的基本单位，线程是cpu调度的基本单位，一个进程中有多个线程，这些线程共享进程内存，进程创建、切换、撤销的系统开销要大于线程
 
 进程通信的方式，优缺点，在什么情况下使用
  低级通信：交换信息少
   - 信号，通知接收进程某个事件已经发生
   - 信号量，计数器，用来控制多个进程对资源的访问，执行一次P操作时，信号量的值应当减1，当其值为小于0时进程应阻塞；在执行V操作时，信号量的值应当加1；
       当其值小于等于0时，应唤醒阻塞队列中的进程
  高级通信：传输大量数据，对用户透明
   - 管道：管道，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，写进程以字符流形式将大量的数据送入（写）管道，
           读进程则从管道中接收（读）数据，需要实现同步互斥，半双工通信方式，数据只能单向流动，如邮槽
     无名管道：有亲缘关系如父子、兄弟进程间的通信
     有名管道：可以进行无亲缘关系进程间的通信，不同机器间的进程通信
   - 消息队列：消息的链接表，具有写权限得进程可以按照一定得规则向消息队列中添加新信息，对消息队列有读权限得进程则可以从消息队列中读取信息
   - 共享内存：划分一块共享存储区，在对共享空间进行写/读操作时，需要使用同步互斥工具，如剪切板的复制粘贴
   - 套接字：可用于不同机器间的进程通信
   比较：
     管道：速度慢、容量有限、只能承载无格式字节流 
     消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。 
     信号量：不能传递复杂信息，只能用来同步。 
     共享内存：能够很容易控制容量，速度快，但要保持同步。

  线程同步是什么，怎么实现，同步机制？与互斥的区别
    线程同步是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性
    遵循的原则，也是临界区(访问临界资源的那段程序)解决冲突的的方法：
     - 空闲让进
     - 忙则等待
     - 有限等待
     - 让权等待(自己不能进临界区时应该释放处理机)
    实现的方式：
     - 信号量：内核对象，多个进程间的各个线程间实现同步，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
     - 事件：内核对象，多个进程间的各个线程间实现同步，通过通知操作的方式来保持多线程同步
    互斥：指某一个资源同时只允许一个访问者对其进行访问，具有唯一性和排它性，无法限制访问者对资源的访问顺序，即访问是无序的 
     - 临界区：非内核对象，单个进程中线程间的互斥，速度快
     - 互斥量：内核对象，多个进程间的各个线程间实现互斥，只有拥有互斥对象的线程才有访问公共资源的权限
  
  生产者消费者问题
     const int buffer=100;
     semaphore mutex=1;
     semaphore empty=buffer;
     semaphore full=0;
     
     void producer(){
      while(1){
       produce();
       p(empty);
       p(mutex);
       put();
       v(mutex);
       v(full); 
       }
     }
     
     void consumer(){
      while(1){
       p(full);
       p(mutex);
       take();
       v(mutex);
       v(empty);
       consume();
       }
     }  
  
  内存池、进程池、线程池
    池化技术：提前保存大量的资源，以备不时之需以及重复使用
    线程池：先启动若干数量的线程，并让这些线程都处于睡眠状态，当需要一个开辟一个线程去做具体的工作时，
           就会唤醒线程池中的某一个睡眠线程，让它去做具体工作，当工作完成后，线程又处于睡眠状态，而不是将线程销毁。
    内存池：内存池是指程序预先从操作系统申请一块足够大内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；
           同理，当程序释放内存的时候，并不真正将内存返回给操作系统，而是返回内存池。当程序退出(或者特定时间)时，内存池才将之前申请的内存真正释放。
 
  什么是死锁？死锁产生的条件？处理方法
    - 死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行
    - 原因：资源有限、进程推进顺序非法
    - 死锁的必要条件
       - 互斥：一个资源每次只能被一个进程使用 
       - 占有并等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放
       - 不可抢占：进程已获得的资源，在未使用完之前，不能强行剥夺
       - 环形等待：若干进程之间形成一种头尾相接的环形等待资源关系
    - 处理方法
        - 死锁预防：确保死锁发生的四个必要条件中至少有一个不成立
            打破占有并等待，资源预先分配策略，在运行前一次性向系统申请它所需要的全部资源，缺点，进程是动态执行的，不可预知的
            无法预知一个进程执行前所需的全部资源，会降低资源利用率，导致降低了进程的并发性
            打破循环等待，资源有序分配策略，对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出
        - 死锁避免: 动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态(系统能按某个顺序为每个进程分配资源，
          并非所有的不安全状态都必然会转为死锁状态)，资源分配图算法和银行家算法
        - 死锁检测与解除：进程终止和资源抢占(选择一个牺牲品、回滚到安全状态 、 饥饿)
   
   饥饿？与死锁的区别
     - 进程长时间等待
     - 相同点：二者都是由于竞争资源而引起的
     - 不同点：处于死锁的进程一定有多个，饥饿的进程可能只有一个
              在饥饿的情形下，系统中有至少一个进程能正常运行，只是饥饿进程得不到执行机会。而死锁则可能会最终使整个系统陷入死锁并崩溃。
         
          
   进程调度算法/处理器调度算法？
     - FCFS(先来先服务)：长作业比较有利
     - 时间片轮转：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，剥夺式调度
     - 高响应比：响应比=(等待时间+要求服务时间)/要求服务时间
     - 多级反馈队列：设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，
          进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部
     - 短作业优先
   
   内存管理技术(操作系统精髓与设计原理P212)
     技术、说明、优势、弱点
     包括连续内存分配(固定分区、动态分区)、非连续内存分配(简单分页、简单分段、虚拟内存分页、虚拟内存分段)
     
   固定分区分配
     分为大小相等和大小不等的固定分区策略
     存在内部碎片、大于最大内存区域的进程无法加载、内存利用不充分
     
   动态分区分配
     又称为可变分区分配，在进程装入内存时，根据进程的大小动态地建立分区，存在外部碎片
     首次适应：空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小能满足要求的第一个空闲分区
     最佳适应：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。
     最坏适应：最大适应，空闲分区以容量递减的次序链接
   
   分页与分段，区别？
     - 分页：主存空间划分为大小相等且固定的块，每个程序的空间也划分为大小相等的块，转入程序时把所有的块装到内存不一定连续的块中(部分装入是虚拟分页)
     - 分段：每个程序也划分为许多段，转入程序时把所有的段装到内存不一定连续的动态分区中(部分装入是虚拟分段)
     - 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。
     - 段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定
     - 段向用户提供二维地址空间；页向用户提供的是一维地址空间
     - 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。
     - 分段没有内部碎片，有外部碎片，分页有内部碎片，没有外部碎片
     - 分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)，分页是为了提高内存利用率
  
   内部碎片：已经被分配出去的的内存空间大于请求所需的内存空间
   外部碎片：指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块
   
   段页式？
     先将用户程序分成若干个段，再把每个段分成若干个页，在段页式系统中，地址结构由段号、段内页号和页内地址三部分所组成
   
   虚拟内存
     - 基于局部性原理，程序的一部分装入内存，就可以启动程序执行，在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，
       然后继续执行程序，在必要时操作系统将内存中暂时不使用的内容换出到外存上。
     - 页面置换算法：
       最佳置换算法：只具有理论意义的算法，在未来最长时间内不会被访问的页置换出去
       先进先出置换算法
       最近最久未使用(LRU)：记录上次页面被访问到现在所经历的时间
       最少使用(LFU)：记录页面被访问次数
       时钟算法clock: 也称最近未使用算法NRU，页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。
             页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面
       改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断
  
  抖动：高频率的页面置换现象
    解决方式：
      - 如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；
      - 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量。
      - 否则，还剩下两个办法：1终止该进程；2增加物理内存容量；
     
  windows下内存管理
    分段、分页、段页式or虚拟内存、内存映射文件、内存堆栈
    
  中断与轮询的特点
    轮询：定时对各种设备轮流询问一遍有无处理要求，有要求的，则加以处理，效率低，等待时间很长，CPU利用率不高
    中断：指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序。
          待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。CPU利用率高
 
  makefile文件的作用？
    定义编译规则，实现自动化编译，make是一个命令工具，解释makefile文件中的指令
    
   缓冲区溢出？危害？原因？
     缓冲区溢出，也叫内存越界，是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上
     危害：
       程序崩溃，拒绝服务
       跳转并且执行恶意代码
     原因：
       程序中没有仔细检查用户输入
       
    Linux文件属性第一位?
      文件类型识别符：-表示普通文件；c表示字符设备（character）；b表示块设备（block）；d表示目录（directory）；l表示链接文件（link）
      
   常见文件系统？
     FAT：Dos、Win，FAT16，FAT32
     NTFS：基于安全性的文件系统，windows NT
     EXT：Linux，EXT2，EXT3(对2扩展，日志式文件系统)，EXT4
     HFS：分层文件系统（Hierarchical File System，HFS），Mac OS
    
   Spooling技术能独占设备改造成可以共享的虚拟设备 
   设备独立性指用户程序独立于具体物理设备的一种特性
 
 
