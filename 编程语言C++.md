# 编程语言(C/C++)

> 都是语言，为什么英语比C++难这么多呢？

---

# 目录

| Chapter 1 | Chapter 2 | Chapter 3| Chapter 4 | 
| :---------: | :---------: | :---------: | :---------: | 
| [编程基础](base)|[面向对象基础](#oop)|[标准模板库](#stl)|[编译及调试](#other)|

---

# 内容

### <span id = "base">编程基础</span>

https://www.cnblogs.com/yjd_hycf_space/p/7495640.html
https://blog.csdn.net/u012864854/article/details/79777991
https://www.cnblogs.com/liufei1983/p/7099401.html

C/C++的内容又多又杂，常常看到有人罗列相关书单，觉得毫无意义，我不相信他们真的完全掌握了其中任何一本。学习任何东西，首先要掌握基本概念，基础不牢地动山摇，因为高级的内容都是通过低级的概念来描述的。当基本概念都没理解透，学习再多都是空中楼阁。这里罗列了一些听基本的问题，虽然看着不难，但是精确理解每句话中的每个词真的并不容易。

1. 变量声明和定义区别？

    - 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
   
    - 相同变量可以再多处声明（外部变量extern），但只能在一处定义。

2. "零值比较"？
    - bool类型：if(flag)
    
    - int类型：if(flag == 0)
    
    - 指针类型：if(flag == null)
    
    - float类型：if((flag >= -0.000001) && (flag <= 0. 000001))

3. strlen和sizeof区别？
    - sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。
    
    - sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化），计算数据所占内存的大小，包括'\0'；strlen的参数只能是字符指针(或者是字符数组的首地址当参数)且结尾是'\0'的字符串，计算字符串实际长度，不包括'\0'。

    - **因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。**
    
    - int a[sizeof(unsigned long)];正确
    
    	char *x = "abcdefg";//strlen(x)=7,只会计算有效的字符个数，不会计算'\0'
	char xx[] = "abcdefg";
	char y[] = { 'a','b','c','d','e','f','g' };
	cout << strlen(x)<<" "<<sizeof(xx) << " " <<strlen(xx) << " " << sizeof(y) << " " <<strlen(y);//7 8 7 7 15？

4. 同一不同对象可以互相赋值吗？
    - 可以，但含有指针成员时需要注意。
    
    - 对比类的对象赋值时深拷贝和浅拷贝。

5. 结构体内存对齐问题？
    - 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
    
    - 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）。
    
    -原因：
          经过内存对齐后，CPU的内存访问速度大大提升
          平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的
    
        struct A
       {
	      double d; //8
	      char c; //1
       };

      int main() {
	  cout << sizeof(A)<<endl; //16
      }

6. static作用是什么？在C和C++中有何区别？
    - static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。
    
    - C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。
    
    - 不能同时用const和static修饰成员函数，在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const              this*。但当一个成员为static的时候，该函数是没有this指针的，只能访问类的 static 成员变量。
    
    - static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。
    
    - 未初始化时，static变量默认值为0。

7. 结构体和类的区别？
    - 结构体的默认限定符是public；类是private。
    - class可以作为模板中的一个关键字 template<Class T>
    
    - ~~结构体不可以继承，类可以。~~ C++中结构体也可以继承。

8. malloc和new的区别？
    - malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。
    
    - malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。
    
    - malloc需要自己计算字节数，返回的是void类型指针（必须进行类型转换），得到的内存中存随机值，new可以自动计算所需要大小，返回的是具体类型指针。

9. 指针和引用区别？
    - 引用只是别名(只读指针实现)，不占用具体存储空间，只有声明没有定义；指针时具体变量，需要占用存储空间。
    
    - 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
    
    - 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
    
    - 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针，所以在使用引用的时候，不需要判断引用是否为空的，但是指针则需要。
    
    - “sizeof 引用" = 指向变量的大小 ， "sizeof 指针"= 指针本身的大小
    
    - 指针可以有多级，而引用只能是一级
    
    引用作为函数参数有哪些特点？
      - 传引用与传指针的效果一样，形参是实参的别名，可以将修改传递回去
      - 传引用没有产生实参的副本，相比于一般的传值时间空间效率都要好
      - 传指针需要给形参分配存储单元，且使用时阅读型较差，引用使用更容易、更清晰
    
    返回值为引用类型？
      typename & functioname(){}
      好处：不产生被返回值的副本
      注意事项：
        - 不能返回局部变量的引用和指针，局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态
	- 不能返回函数内部动态分配的内存引用，因为引用仅仅是别名，无法释放内存
	- 可以返回类成员的引用，最好是const
	- 流操作符重载和赋值运算符重载必须为引用才能实现连续处理。
	- 必须返回一个新对象的函数的正确方法就是让这个函数返回一个新对象而不是引用，如四则运算符，因此，它们必须构造一个对象作为返回值，
	可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。
int  a=4;

int  &f(int  x)

{    a=a+x;

      return  a;

}

int main(void)

{    int   t=5;

     cout<<f(t)<<endl;  //= 9

    f(t)=20;           //a = 20

    cout<<f(t)<<endl;  // t = 5,a = 20  a = 25

     t=f(t);          //   a = 30 t = 30

    cout<<f(t)<<endl;  // t = 60

}
	
10. 宏定义和函数有何区别？
    - 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
    
    - 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。
    
    - 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
    
    - 宏函数不要在最后加分号。
    
    - #define MIN(a,b)((a)<=(b)?(a):(b))

11. 宏定义和const区别？
    - 宏替换发生在编译阶段之前的预处理，属于文本插入替换；const作用发生于编译过程中。
    
    - 宏不检查类型；const会检查数据类型。
    
    - 宏定义的数据没有分配内存空间，只是插入替换掉，存储在代码段中；const定义的变量只是值不能改变，但要分配内存空间，存储在数据段。

12. 宏定义和typedef区别？
    - 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。
    
    - 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。
    
    - 宏不检查类型；typedef会检查数据类型。
    
    - 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。
    
    - 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。

13. 宏定义和内联函数(inline)区别？
    - 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
    
    - 内联函数本身是函数，强调函数特性，具有重载等功能。
    
    - 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。
    
    -  内联函数在编译的时候进行代码插入，省去函数的调用的压栈出栈的开销，提高效率，但是会增加整体的代码量

14. 条件编译#ifdef, #else, #endif作用(C/C++语言中的宏定义)？
    - 防止头文件被重复包含
    - 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。
    
    - 用于子程序前加#define DEBUG用于程序调试。
    
    - 应对硬件的设置（机器类型等）。
    
    - 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。
    
    - 判断一段程序是C编译程序还是C++编译程序编译的
    
    　  #ifdef __cplusplus
　　　　    cout << "c++" << endl;
　　    #else
　　　　    cout << "c";
　    　#endif
      
    - #pragma once是编译器相关的，有的编译器支持，有的编译器不支持
    
15. 区别以下几种变量？

        const int a;
        int const a;
        const int *a;
        int *const a;

    - int const a和const int a均表示定义常量类型a。
    
    - const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)
    
    - int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)

16. volatile有什么作用？
    - volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去内存重新读取这个变量的值，而不是读寄存器内的备份。
    
    - 多线程中被几个任务共享的变量需要定义为volatile类型，保证线程对变量修改的可见性。

17. 什么是常引用？
    - 常引用可以理解为常量指针，形式为const typename & refname = varname。
    
    - 常引用下，原变量值不会被别名所修改。
    
    - 原变量的值可以通过原名修改。
    
    - 常引用通常用作只读变量别名或是形参传递。
    
    void bar(string & s) {
	cout << s << endl;
    }

    int main() {
	bar("hello word");//报错，无法用const char[11]初始化string &，需要将形参改为 const string& s
    }
    

18. 区别以下指针类型？

        int *p[10]
        int (*p)[10]
        int *p(int)
        int (*p)(int)
	int (*p[10])(int)

    - int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
    
    - int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
    
    - int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
    
    - int (*p)()是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。
    
    - int (*p[10])(int)是函数指针数组，每个指针指向int f(int)函数

19. 常量指针和指针常量区别？
    - 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p。
    
    - 指针常量是一个不能给改变指向的指针。如int *const p。

20. a和&a有什么区别？

        假设数组int a[10];
        int (*p)[10] = &a;

    - a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
    
    - &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
    
    - 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。
    
    	int a[5]{ 1,2,3,4,5 };
	
	int(*p1)[5] = &a + 1;//数组指针，二级指针，类型为int (*)[5]
	
	int *p2 = (int*)(&a + 1);//int*，一级指针
	
	printf("%d,%d,%d,%d", *(a + 1), *(p1 - 1),**(p1 - 1),*(p2-1));//2,&a[0],a[0],a[4]

21. 数组名和指针（这里为指向数组首元素的指针）区别？
    - 二者均可通过增减偏移量来访问数组中的元素。

    - 数组名不是真正意义上的指针，可以理解为常指针(指针常量？常量指针？)，所以数组名没有自增、自减等操作。
    
    - sizeof(数组名)为数组所有元素所占的字节大小，sizeof(指针名)为一个指针类型的大小
    
    - 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。

22. 野指针是什么？
    - 也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。
    
    - 产生原因及解决办法：
         - 指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。
    
         - 指针free或delete之后没有及时置空 => 释放操作后立即置空。
	 
	 - 指针操作超越了变量作用域范围，如返回指向函数调用里申请的空间的指针 => 在变量的作用域结束之前释放掉地址空间并让指针指向空。

23. 堆和栈的区别？

    - 申请方式不同。

        - 栈由系统自动分配。

        - 堆由程序员手动分配。

    - 申请大小限制不同。

        - 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。

        - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。

    - 申请效率不同。

        - 栈由系统分配，速度快，不会有碎片。

        - 堆由程序员分配，速度慢，且会有碎片。

24. delete和delete[]区别？

    - delete只会调用一次析构函数。

    - delete[]会调用数组中每个元素的析构函数。

25. 结构体与联合？
    - 都可以由不同数据类型的成员组成
    - 联合所有成员共用一块地址空间，结构体不同成员的存放地址不同
    - 对于联合的不同成员赋值时原来成员的值就不存在了，而对于结构的不同成员赋值是互不影响的。
    
26. 描述内存分配方式以及它们的区别?
    - 静态存储区：在程序编译时期进行分配，在程序的整个运行期间都存在，存储全局变量、static变量
    - 栈区分配：运行时系统进行分配，存储局部变量、函数参数，先进先出
    - 堆区分配：运行时程序员动态申请，生存周期用户自己指定，顺序随意
    
    - 常量存储区：常量(const)存于此处,此存储区不可修改，字符串常量
    - 程序代码区：存放二进制代码
    char a[] = "khell"; // 栈中分配内存，所以可以修改。
    a[0] = 'x'; // 可以 没有问题
    char *p = "khell";//常量字符串，存储在字符常量区，不可以修改
    p[0] = 'x'; // 编译可以，运行时错误
    
    
    char str1[] = "abc";
　　char str2[] = "abc";

　　const char str3[] = "abc";
　　const char str4[] = "abc";

　　const char *str5 = "abc";
　　const char *str6 = "abc";

　　char *str7 = "abc";
　　char *str8 = "abc";

　　cout << ( str1 == str2 ) << endl;//0  分别指向各自的栈内存
　　cout << ( str3 == str4 ) << endl;//0  分别指向各自的栈内存
　　cout << ( str5 == str6 ) << endl;//1指向文字常量区地址相同
　　cout << ( str7 == str8 ) << endl;//1指向文字常量区地址相同
 
 27. 全局变量和局部变量？
     - 生存周期不同：全局变量为整个程序的运行阶段，局部变量为函数调用阶段
     - 使用范围不同：全局变量各部分都能用到，局部变量只能在局部使用
     - 存放的位置不同；全局变量放在静态区，局部变量放在堆栈里
     
 28. C中变量的存储类型有哪些？
     - auto int a; 自动存储，默认auto
     - static int a; 静态存储
     - register int i; 频繁使用的变量放在CPU的寄存器上，只有局部变量才可以被声明用register修饰，不能用取地址获(获取内存地址)取用register修饰的变量的地址
     - extern int a;
       extern修饰的变量和函数定义在别的文件中，这里只是声明，可以声明多次
       extern "C" void fun(int a,int b);则告诉编译器在编译fun这个函数时候按着C的规矩去翻译，而不是C++的
        C++语言支持函数重载，C语言不支持函数重载，函数被C++编译器编译后在库中的名字与C语言的不同
       
 29. memset函数，strcpy，memcpy，strcat，strcmp实现
     类String 的构造函数，析构函数，拷贝构造函数和赋值函数
      https://blog.csdn.net/gao1440156051/article/details/51496782
      https://www.cnblogs.com/flipped/p/5541121.html
      
      memcpy sprintf strcpy区别
      https://blog.csdn.net/lickylin/article/details/7856779
      char*strcpy(char *dest, const char *src);
      int sprintf(char*str, const char *format, ...)
      void *memcpy(void*dest, const void *src, size_t n)
 
 30. const作用
     - 修饰变量为只读，一定要初始化，后面不可修改
     - 修饰函数参数和返回值
     - 修饰成员函数，如char get() const;可以访问const成员变量和非const成员变量，但不能修改任何变量
     - 修饰对象，只能访问const成员函数不能访问非const成员函数，因为const* this指针无法传给*this指针，而非const对象可以访问任意的成员函数,包括const        成员函数
     
 31. i++是否为原子操作？
      i++分为三个阶段：内存到寄存器、寄存器自增、写回内存。这三个阶段中间都可以被中断分离开.
 
 32. 智能指针？
      - 当类中有指针成员时，使用智能指针，实现指针指向的对象的共享
      - 通过引用计数跟踪该类有多少个对象的指针指向同一对象实现
      - 构造函数中计数初始化为1；
      - 拷贝构造函数中计数值加1；
      - 赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；
      - 析构函数中引用计数减一；
      - 在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象
   
  33. #include"file.h"和#include<file.h>
  
  34. 函数参数入栈的顺？
       - 从右端往左进入栈的。为了支持可变参数，左边的参数在栈顶就可在不知道参数个数的情况下通过栈指针取值
       
  35. 设置地址为0x67a9整型变量的值为0xaa66
  
       int *p;
       
       p=(int*)0x67a9;//整型数据可以强制转化为指针数据
       
       *p=0xaa66;

### <span id = "oop">面向对象基础</span>

能够准确理解下面这些问题是从C程序员向C++程序员进阶的基础。当然了，这只是一部分。

1. 面向对象三大特性？

    - 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。
    
    - 继承性：让某种类型对象获得另一个类型对象的属性和方法。
    
    - 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。

2. public/protected/private的区别？
    - public的变量和函数在类的内部外部都可以访问。
    
    - protected的变量和函数只能在类的内部和其派生类中访问。
    
    - private修饰的元素只能在类内访问。

3. 对象存储空间？
    - 非静态成员的数据类型大小之和。
    
    - 编译器加入的额外成员变量（如指向虚函数的指针）。
    
    - 为了边缘对齐优化加入的panding。

4. C++空类有哪些成员函数?
    - 首先，空类大小为1字节。
    
    - 默认函数有：
        - 构造函数
    
        - 析构函数
    
        - 拷贝构造函数
    
        - 赋值运算符
	
        - 取址运算符（返回this）
	
        - 取址运算符const
	
	只有在需要时才会产生，在声明时不会产生任何成员函数，即定义一个类而不创建对象时，不会生成这些函数
	

5. 构造函数能否为虚函数，析构函数呢？
    - 析构函数：
        - 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
    
        - 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。
    
        - 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。
    
    - 构造函数：
        - 构造函数不能定义为虚函数，不仅如此，构造函数中还不能调用虚函数。因为那样实际执行的是父类对应的函数，因为自己还没有构造好（构造顺序先基类再派生类）。

6. 构造函数调用顺序，析构函数呢？
    - 基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。
    
    - 成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。
    
    - 派生类的构造函数。
    
    - 析构函数与之相反。

7. 拷贝构造函数中深拷贝和浅拷贝区别？
    - 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。
    
    - 浅拷贝仅仅是拷贝指针字面值。
    
    - 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。

8. 拷贝构造函数和赋值运算符重载的区别？
    - 拷贝构造函数是函数，赋值运算符是运算符重载。
    
    - 拷贝构造函数会生成新的类对象，赋值运算符不能。
    
    - 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。
    
    - 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

            Student s;
            Student s1 = 2;    // 调用拷贝构造函数
            Student s2;
            s2 = s;    // 赋值运算符操作

    **注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符**

9. 虚函数和纯虚函数区别？
    - 虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。
    
    - 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。

10. 覆盖、重载和隐藏的区别？
     - 覆盖(override，子类改写父类的虚函数)是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中，实现运行时多态。
    
     - 隐藏(或叫重写，overwrite，子类改写父类的函数，从而屏蔽父类函数)是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。
    
     - 重载(overload)是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数，实现编译时多态。

11. 在main执行之前执行的代码可能是什么？

    - static变量和全局变量的初始化
    - 全局对象的构造函数。
    - 全局对象的析构函数、static变量和全局变量的资源释放在main之后执行，
    
    

12. 哪几种情况必须用到初始化成员列表？
   
    - 初始化一个常量const成员。

    - 初始化一个引用reference成员。

    - 调用一个基类的构造函数，而该函数有一组参数。

    - 调用一个数据成员对象的构造函数，而该函数有一组参数。
    
     https://blog.csdn.net/winson_jason/article/details/7239591
    原因：
    构造函数的 {} 内的操作只能是赋值，
    执行到构造函数的大括号里的时候，所有成员的空间都已经分配好了，无论是否已经被初始化过，对其调用的“=”只能是赋值
    常量变量和引用只能被初始化，所以必须在初始化列表中完成
    
13. 什么是虚指针？

    - 虚指针或虚函数指针是虚函数的实现细节。

    - 虚指针指向虚表结构，虚函数表实质是函数指针数组，数组里面存放了一系列函数地址。
    
    - 类才包含虚函数表，派生类会生成一个兼容基类的虚函数表，对象不包含虚函数表，只有虚指针，存在于对象实最前面的位置
    
    - 虚函数表在编译时期生成，保存在只读数据段(静态存储区？常量区？)

    
14. 重载和函数模板的区别？

    - 重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。

    - 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。

15. this指针是什么？

    - this指针是类的指针，指向对象的首地址。

    - this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。

    - this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

16. 类模板是什么？

    - 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。

    - 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。

    - 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。

17. 构造函数和析构函数调用时机？

    - 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。

    - 局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数。

    - 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。

    - 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。
    
18. c++是类型安全型的吗？
     https://blog.csdn.net/u010025211/article/details/48626687
    - 不是，四种强制类型转换
    - static_cast:可以实现C++中内置基本数据类型之间的相互转换，如果涉及到类的话，只能在有相互联系的类型中进行相互转换，不一定包含虚函数
      int c=static_cast<int>(7.987); 
    - const_cast：只能在同种数据类型上加上或去掉const
    - reinterpret_cast: 重解释类型转换，转化任何的内置数据类型和指针类型为其他的类型
    - dynamic_cast: 基类中一定要有虚函数，否则编译不通过其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查，
	            不能用于内置的基本数据类型的强制转换，如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL 
	            基类指针可以指向派生类对象，从而实现多态，但是派生类指针不可以指向基类对象，因为多出来的属性无法正常访问
	
19. 如何实现类对象只能静态分配或动态分配？ https://blog.csdn.net/u012411498/article/details/80816613
    - 只能静态：A a;将new运算符设为私有
    - 只能动态：A* p = new A();析构函数设为private，类的析构函数在类外部无法访问，则编译器拒绝在栈空间上为类对象分配内存
    不能实例化？
    - 抽象基类
    - 构造函数私有
     
20. explicit
    - 修饰类构造函数防止隐式转换(可以用单个实参来调用的构造函数定义了从形参类型到该类类型的一个隐式转换)
      如将字符作为参数传给代表长度的整形变量
      
21. 虚基类
    - 在C++中,如果在多条继承路径上有一个公共的基类,那么在这些路径中的某几条路径的汇合处,这个公共的基类就会产生多个实例（从而造成二义性）.如果想使这个       公共的基类只产生一个实例,则可将这个基类说明为虚基类. 这要求在从base类派生新类时,使用关键字virtual将base类说明为虚基类
    - 虚继承的原理过程是通过虚基类指针和虚基类表来实现，一个虚基类指针占用四个字节的大小，虚基类表不占用类存储空间大小，在虚基类表中存储的时虚基类相对       于派生类的偏移量，这样就根据偏移量找到虚基类成员。如果虚继承的类被继承，该派生类同样有一份虚积类指针的拷贝。这样就能保证虚基类中在子类中存在一份        拷贝。避免有多分拷贝造成二义性。
    
    class base{protected:int b..};
    
    clase base1:virtual public base{..}; //说明base为base1虚基类
    
    clase base2:virtual public base{..}; //说明base为base2虚基类
    
    clase derived:public base1,public base2 {..};//多重继承有二义性，一些面向对象语如Java、C#、PHP不支持多重继承(一个类可以同时继承多个类)
    
    

 22. 子类不能继承父类的哪些函数？为什么
     - 有构造函数
     - 析构函数
     - 拷贝构造函数
     
 23. C ++ 在c基础上加了什么？
 
　   - 包含全部的C语言部分。
　　 - 面向对象部分，封装，继承，多态。
　　 - 泛型编程部分，模板，方便使用。
       函数模板：函数功能一样，数据类型不一样
       template<typename t1,typename t2,typename t3>
       t1 f(t1 a,t2 b,t3 c)
       类模板：类的功能一样，数据类型不一样
       template<class t>
       class Min{
      	 private:
		t a;
		t b;
	public:
		Compare(t a,t b){
		return (a>b)?a:b
		}
	}
	
　　 - STL库。

 24.虚函数不能是内联函数、静态成员函数？
    内联函数是在编译时期展开，而虚函数的特性是运行时才动态联编，所以两者矛盾，不能定义内联函数为虚函数
    静态成员函数不属于某一个具体的对象，而虚函数调用需要根据具体对象内的虚函数指针访问虚函数表，两者矛盾
 
### <span id = "stl">标准模板库</span>

STL内容虽然看起来很多，单独成书都不是问题（《STL源码剖析》），但从实际使用状况来看，我认为只需要知道以下几点就可以了：

- 怎么用？

    各种STL基本的增删改查怎么使用。每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。有些功能只是出于通用性考虑才存在的，但对于相应的STL这些操作完全可以忽略。所以我对STL使用的看法是，不需要花太多时间去了解所有功能，只要掌握最基本的即可，要把精力放在对需求的了解并选择适合的数据结构。

- 怎么实现？

    本身STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。

- 如何避免错误？

    在第二阶段了解了STL的实现之后，我们已经可以很清楚地知道他们底层使用的是什么数据结构以及该数据结构做什么操作比较高效。但还有一点需要注意的就是怎么才能用对他们，避免一些未知的错误，比如迭代器失效问题。

**string**


**vector**

用法：

        定义：
            vector<T> vec;

        插入元素：
            vec.push_back(element);
            vec.insert(iterator, element);

        删除元素：
            vec.pop_back();
            vec.erase(iterator);

        修改元素：
            vec[position] = element;

        遍历容器：
            for(auto it = vec.begin(); it != vec.end(); ++it) {......}

        其他：
            vec.empty();    //判断是否空
            vec.size();    // 实际元素
            vec.capacity();    // 容器容量
            vec.begin();    // 获得首迭代器
            vec.end();    // 获得尾迭代器
            vec.clear();    // 清空

实现：

[模拟Vector实现](https://github.com/linw7/Skill-Tree/blob/master/code/my_vector.cpp)

- 线性表，数组实现。
    - 支持随机访问。
    
    - 插入删除操作需要大量移动数据。

- 需要连续的物理存储空间。

- 每当大小不够时，重新分配内存（*2），并复制原内容。

错误避免：

[迭代器失效](https://github.com/linw7/Skill-Tree/blob/master/code/vector_iterator.cpp)

- 插入元素
    - 尾后插入：size < capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
    
    - 中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。

- 删除元素
    - 尾后删除：只有尾迭代失效。
    
    - 中间删除：删除位置之后所有迭代失效。

**map**

用法：

        定义：
            mao<T_key, T_value> map;

        插入元素：
            map.insert(pair<T_key, T_value>(key, value));    // 同key不插入
            map.insert(map<T_key, T_value>::value_type(key, value));    // 同key不插入
            map[key] = value;    // 同key覆盖

        删除元素：
            map.erase(key);    // 按值删
            map.erase(iterator);    // 按迭代器删

        修改元素：
            map[key] = new_value;

        遍历容器：
              for(auto it = vec.begin(); it != vec.end(); ++it) {......}

实现：

[RBTree实现](https://github.com/linw7/Skill-Tree/tree/master/code/RBTree)

- 树状结构，RBTree实现。
    - 插入删除不需要数据复制。
    
    - 操作复杂度仅跟树高有关。

- RBTree本身也是二叉排序树的一种，key值有序，且唯一。
    - 必须保证key可排序。

基于红黑树实现的map结构（实际上是map, set, multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，其所有操作都可以在O(logn)时间范围内完成。另外，基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果，这点特性在很多操作中非常方便。

面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。

1. 它是二叉排序树（继承二叉排序树特显）：
    - 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。

    - 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。

    - 左、右子树也分别为二叉排序树。

2. 它满足如下几点要求：
    - 树中所有节点非红即黑。

    - 根节点必为黑节点。

    - 红节点的子节点必为黑（黑节点子节点可为黑）。

    - 从根到NULL的任何路径上黑结点数相同。

3. 查找时间一定可以控制在O(logn)。

4. 红黑树的节点定义如下：
    ```C++
    enum Color {
        RED = 0,
        BLACK = 1
    };
    struct RBTreeNode {
        struct RBTreeNode*left, *right, *parent;
        int key;
        int data;
        Color color;
    };
    ```
所以对红黑树的操作需要满足两点：1.满足二叉排序树的要求；2.满足红黑树自身要求。通常在找到节点通过和根节点比较找到插入位置之后，还需要结合红黑树自身限制条件对子树进行左旋和右旋。

相比于AVL树，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。

从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列......最长路径不会大于2n，这里路径长就是树高。


**set**

---

### <span id = "other">编译及调试</span>

**编译**

预处理

- 展开所有的宏定义，完成字符常量替换。

- 处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。

- 处理#include指令，将被包含的文件插入到该指令所在位置。

- 过滤掉所有注释语句。

- 添加行号和文件名标识。

- 保留所有#pragma编译器指令。

编译

- 词法分析。

- 语法分析。

- 语义分析。

- 中间语言生成。

- 目标代码生成与优化。

链接

各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。

- 静态链接

    静态链接最简单的情况就是在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快，但缺点也有很多，在讲动态链接时会比较一下。

    既然静态链接是对目标文件的打包，这里介绍些打包命令。

        gcc -c test1.c    // 生成test1.o
        gcc -c test2.c    // 生成test2.c
        ar cr libtest.a test1.o test2.o

    首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。

        gcc -o main main.c -ltest

- 动态链接

    静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果多个程序都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。

    动态链接在形式上倒是和静态链接非常相似，首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。不过动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。

        gcc -fPIC -c test1.c 
        gcc -fPIC -c test2.c
        gcc -shared test1.o test2.o -o libtest.so

    使用动态链接的用法也和静态链接相同。

        gcc -o main main.c -ltest

如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是/usr/lib，我们可以将库文件拷贝到那个目录下再链接。

比较静态库和动态库我们可以得到二者的优缺点。

- 动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。

- 动态库另一个有点就是更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。

- 不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。

makefile编写

对于大的工程通常涉及很多头文件和源文件，编译起来很很麻烦，makefile正是为了自动化编译产生的，makefile像是编译说明书，指示编译的步骤和条件，之后被make命令解释。

- 基本规则

        A:B
        (tab)<command>

    其中A是语句最后生成的文件，B是生成A所依赖的文件，比如生成test.o依赖于test.c和test.h，则写成test.o:test.c test.h。接下来一行的开头必须是tab，再往下就是实际的命令了，比如gcc -c test.c -o test.o。

- 变量

    makefile的书写非常像shell脚本，可以在文件中定义"变量名 = 变量值"的形式，之后需要使用这个变量时只需要写一个$符号加上变量名即可，当然，和shell一样，最好用()包裹起语句来。

**链接**

符号解析

- 可重定位目标文件

    对于独立编译的可重定位目标文件，其ELF文件格式包括ELF头（指定文件大小及字节序）、.text（代码段）、.rodata（只读数据区）、.data（已初始化数据区）、.bss（未初始化全局变量）、.symtab（符号表）等，其中链接时最需要关注的就是符号表。每个可重定位目标文件都有一张符号表，它包含该模块定义和引用的符号的信息，简而言之就是我们在每个模块中定义和引用的全局变量（包括定义在本模块的全局变量、静态全局变量和引用自定义在其他模块的全局变量）需要通过一张表来记录，在链接时通过查表将各个独立的目标文件合并成一个完整的可执行文件。

- 解析符号表

    解析符号引用的目的是将每个引用与可重定位目标文件的符号表中的一个符号定义联系起来。

重定位

- 合并节

    多个可重定位目标文件中相同的节合并成一个完整的聚合节，比如多个目标文件的.data节合并成可执行文件的.data节。链接器将运行时存储地址赋予每个节，完成这步每条指令和全局变量都有运行时地址了。

- 重定位符号引用

    这步修改全部代码节和数据节对每个符号的符号引用，使其指向正确的运行时地址。局部变量可以通过进栈、出栈临时分配，但全局变量（"符号"）的位置则是在各个可重定位目标文件中预留好的。通过上一步合并节操作后，指令中所有涉及符号的引用都会通过一定的寻址方式来定位该符号，比如相对寻址、绝对寻址等。

可执行目标文件

- ELF头部

    描述文件总体格式，并且包括程序的入口点（entry point），也就是程序运行时执行的第一条指令地址。

- 段头部表

    描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对齐、执行权限等。实际上通过段头部表描绘了虚拟存储器运行时存储映像，比如每个UNIX程序的代码段总是从虚拟地址Ox0804800开始的。

- 其他段

    和可重定位目标文件各段基本相同，但完成了多个节的合并和重定位工作。

加载

- 克隆

    新程序的执行首先需要通过父进程外壳通过fork得到一个子进程，该子进程除了pid等标识和父进程不同外其他基本均与父进程相同。

- 重新映射

    当子进程执行execve系统调用时会先清空子进程现有的虚拟存储器段（简而言之就是不再映射到父进程的各个段），之后重新创建子进程虚拟存储器各段和可执行目标文件各段的映射。这个阶段我们可以理解为对复制来的父进程页表进程重写，映射到外存中可执行文件的各个段。

- 虚页调入

    加载过程并没有实际将磁盘中可执行文件调入内存，所做的工作紧紧是复制父进程页表、清空旧页表、建立新页表映射工作。之后加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得指令的虚拟地址后，若包含该指令或数据的页尚未调入内存则将其从外存中调入，调入内存后修改页表得到虚拟页号和物理页号的对应关系。之后重新取同一条指令或数据时因该页已经被调入内存，所以通过虚拟地址得到虚拟页号，虚拟页号通过查页表可以得到物理页号，通过物理页号 + 页内偏移得到具体的物理地址，此时可以通过物理地址取得想要的数据。
    
    设计模式
    https://blog.csdn.net/woxiaohahaa/article/details/51344409
    https://www.cnblogs.com/xzy1210/p/3849253.html
    - 单例模式：保证只有一个实例，并提供全局访问点
       应用场景：共享资源，初始化一次socket资源；管理器
    - 工厂模式：定义创建对象的接口，让子类决定实例化哪个类，被创建的实例通常有共同的父类
    //懒汉模式单线程
    class Singleton {
private:
	static Singleton* ps;
public:
	static Singleton* getSingleton() {
		if (!ps) {
			ps = new Singleton;
		}
		return ps;
	}
};
Singleton* Singleton::ps = NULL;

//饿汉模式
class Singleton {
private:
	static Singleton* ps;
public:
	static Singleton* getSingleton() {
		return ps;
	}
};
Singleton* Singleton::ps = new Singleton;
